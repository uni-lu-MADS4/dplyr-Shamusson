---
title: "Data wrangling"
author: "Andrei Nazarov"
date: "2025-10-13"
output: html_document
editor: source
---




## Part one - Wrangling

This tutorial will allow you to explore `dplyr` functionality based on the previous lecture. Every question can be answered with a combination of `|>` pipes. You should refrain from using temporary variables and statements outside of the range of the tidyverse.  

The first part does not require joins or pivots.

### Import the [data from the website](https://biostat2.uni.lu/practicals/data/judgments.tsv). 
Assign to the name `judgments` and correct the column types where needed.

```{r}
library(tidyverse)
judge_url <- "https://biostat2.uni.lu/practicals/data/judgments.tsv"
judgments <- readr::read_tsv(judge_url)
judgments <- readr::read_tsv("data/judgments.tsv", show_col_types = FALSE)
judgments <- readr::read_delim("data/judgments.tsv")
judgments
```


### Use `glimpse()` to identify columns and column types.

What are the dimensions of the data set.

```{r}
glimpse(judgments)
```

Select all columns that refer to the STAI questionnaire.

```{r}
select(judgments, starts_with("STAI"))
```

Retrieve all subjects younger than 20 which are in the stress group. The column for the group is condition.

```{r}
filter(judgments, age < 20 & condition == "stress")
```

Arrange all observations by STAI_pre so that the subject with the lowest score is on top. What is the subject in question?

```{r}
judgments |> 
  arrange(STAI_pre) |> 
  relocate(subject, STAI_pre)
```

### Exercise 1 

You can combine the following tasks into a single statement.

#### Select columns
Select `gender`, `subject`, `age` and referring to the `STAI` questionnaire.

```{r}
select(judgments, gender, subject, age, starts_with("STAI"))
```


#### Select all subjects with `STAI_pre` greater than 65 and `STAI_post` greater than 40

```{r}
select(judgments, gender, subject, age, starts_with("STAI")) |> 
  filter(STAI_pre > 65 & STAI_post > 40)
```


#### Sort the observations by `STAI_pre` so that the subject with the highest score is on top.

```{r}
select(judgments, gender, subject, age, starts_with("STAI")) |> 
  filter(STAI_pre > 65 & STAI_post > 40) |> 
  arrange(desc(STAI_pre))
```

#### For better readability, move the subject, STAI_pre and STAI_post columns to the first positions.

```{r}
select(judgments, gender, subject, age, starts_with("STAI")) |> 
  filter(STAI_pre > 65 & STAI_post > 40) |> 
  arrange(desc(STAI_pre)) |> 
  relocate(subject, STAI_pre, STAI_post)
```

#### Check if the data set contains duplicated rows

::: {.callout-tip}
### Tip
Compare the number of rows in the raw input table with the number of rows 
in a de-duplicated table containing unique rows only. 
:::

```{r}
distinct(judgments) |> nrow()
judgments |> nrow()
```



### Exercise 2

#### Create a new column called `STAI_pre_category` 

It should contain "low", "normal" and "high" entries depending on the `STAI_pre` values:

  * if `STAI_pre` is less than `25` assign "low",
  
  * if `STAI_pre` is over `65` assign "high",
  
  * for all other values assign "normal".

```{r}
case_when(
  judgments$STAI_pre < 25 ~ "low",
  judgments$STAI_pre > 65 ~ "high",
  .default = "normal"
  ) -> judgments$STAI_pre_category
judgments$STAI_pre_category
```

#### Arrange the table by `STAI_pre` in a descending manner.

```{r}
arrange(judgments, desc(STAI_pre))
```


### Display distinct values in `STAI_pre` and `STAI_pre_category`.

```{r}
judgments$STAI_pre |> unique()
judgments$STAI_pre_category |> unique()
```


##### Normalize the values in the REI group
Divide all entries in the REI questionnaire by 5, the maximal value.

```{r}
judgments |> mutate(across(starts_with("REI"), `/`, 5))
```


